fid= fopen('wordlist-preao-20201103.txt','r');
dicionario= textscan(fid,'%s');
fclose(fid);
dicionario= dicionario{1,1};
dicionario{100};
y=length(dicionario);

newD=cell(2,1); %creates new cell array words with only the involving letters a/m/o/r
j=1;
set_of_letters= 'amor';

for i=1:y
    if min(ismember(dicionario{i},set_of_letters))==1 %checks if a/m/o/r are the only letters in the word
        newD{j}=dicionario{i};  %if true adds the word to the new cell array
        j=j+1;
    end
end


pairs={'aa';'am';'ao';'ar';'ma';'mm';'mo';'mr';'oa';'om';'oo';'or';'ra';'rm';'ro';'rr'}; %possible pairs
pairs(:,2) ={0};   %adds a column to put the number of times each sequence of letters appears
l=length(newD);
p=length(pairs);
idx=0;

for i=1:p
    for j=1:l
       idx=idx+numel(strfind(newD{j},pairs{i}));    %sums the number of columns of strfind to get 
                                                    %the number of occurence of pairs per word
    end
    pairs{i,2}=idx;                     %puts the respective number on the respective row
    idx=0;                              %resets idx
end

pairs(:,3)={0}; %add another column for the probabilities of each transition state

for i=1:p
    pairs{i,3}=pairs{i,2}/l;    %adds the probabilities to each row
end

%counters to use for end of word probability
fA=0;
fM=0;
fO=0;
fR=0;

for i=1:l
    %if the last letter of the word index i is 'x' add 1 to counter
    if newD{i}(end)=='a'
        fA=fA+1;
    elseif newD{i}(end)=='m'
        fM=fM+1;
    elseif newD{i}(end)=='o'
        fO=fO+1;
    elseif newD{i}(end)=='r'
        fR=fR+1;
    end
end
T=[
    pairs{1,3} pairs{5,3} pairs{9,3}  pairs{13,3} 0
    pairs{2,3} pairs{6,3} pairs{10,3} pairs{14,3} 0
    pairs{3,3} pairs{7,3} pairs{11,3} pairs{15,3} 0
    pairs{4,3} pairs{8,3} pairs{12,3} pairs{16,3} 0
    fA/l       fM/l       fO/l        fR/l        1 ];
%counters for each word starting with the letter a/m/o/r
cA=0;
cM=0;
cO=0;
cR=0;

%adds 1 to a counter if the words starts with its respective
%letter
for i=1:y
    if strcat(dicionario{i}(1))=='a'
        cA=cA+1;
    elseif strcat(dicionario{i}(1))=='m'
        cM=cM+1;
    elseif strcat(dicionario{i}(1))=='o'
        cO=cO+1;
    elseif strcat(dicionario{i}(1))=='r'
        cR=cR+1;
    end
end

%calculates the probabilites of the words starting by the given letters
pA=cA/y;
pM=cM/y;
pO=cO/y;
pR=cR/y;

n=1000;
input=6;    %maximum length of word (test with 6/8/4/infinite)
le=cell(n,1);    %creates cell array n by 1

P=[pA pM pO pR];
S=[1  2  3  4];

for i=1:n
    C = cumsum(P);  %gets the cumulative sum of the probability matrix
    one = S(1+sum(C(end)*rand>C));   %chooses which state (S) will be the first given the odds
    state=crawl(T,one,5);
    state=state(1:length(state)-1);
    word=set_of_letters(state);
    if length(word)>=input
        newW=extractBefore(word,input+1); %only gets the word till the maximum input number
        le{i}=newW;     %adds the word to the cell array
    else
        le{i}=word;                  %adds the word to the cell array
    end
end 
ule=unique(le);
fprintf('5)Total of different words with maximum input n: %0.1f\n',length(ule));

c=0; %counter of words that are member of the portuguese word list
for i=1:length(le)
    if ismember(le{i},dicionario)
        c=c+1;                          %if a random word that is generated by the random word generator
    end                                 %is member of the portuguese list
end                                     %we increment the counter 

prob=c/n;       %calculates the probability that is asked for

fprintf('5)The probability of the random word generator to generate a valid Portuguese word is %0.03f\n',prob);








function state = crawl(H, first, last)
% the sequence of states will be saved in the vector "state"
% initially, the vector contains only the initial state:
state = [first];
% keep moving from state to state until state "last" is reached:
while (1)
state(end+1) = nextState(H, state(end));
if (state(end) == last)
break;
end
end
end
% Returning the next state
% Inputs:
% H - state transition matrix
% currentState - current state
function state = nextState(H, currentState)
% find the probabilities of reaching all states starting at the current one:
probVector = H(:,currentState); % probVector is a row vector
n = length(probVector); %n is the number of states
% generate the next state randomly according to probabilities probVector:
state = discrete_rnd(1:n, probVector);
end
% Generate randomly the next state.
% Inputs:
% states = vector with state values
% probVector = probability vector
function state = discrete_rnd(states, probVector)
U=rand();
i = 1 + sum(U > cumsum(probVector));
state= states(i);
end



